import * as fs from 'fs/promises';
import * as path from 'path';
import type { C4ModelOutput } from '../orchestrator/c4-model-orchestrator';

export interface C4ModelFormatterOptions {
  outputDir: string;
}

/**
 * Formatter for C4 Model documentation
 * Generates markdown files from C4ModelOutput
 */
export class C4ModelFormatter {
  async format(output: C4ModelOutput, options: C4ModelFormatterOptions): Promise<void> {
    const { outputDir } = options;

    // Ensure output directory exists
    await fs.mkdir(outputDir, { recursive: true });

    // Generate all markdown files and PlantUML diagrams
    await Promise.all([
      this.writeIndexFile(output, outputDir),
      this.writeMetadataFile(output, outputDir),
      this.writeContextFile(output, outputDir),
      this.writeContainersFile(output, outputDir),
      this.writeComponentsFile(output, outputDir),
      this.writeRecommendationsFile(output, outputDir),
      this.writeChangelogFile(output, outputDir),
      this.writePlantUMLFiles(output, outputDir),
    ]);
  }

  private async writeIndexFile(output: C4ModelOutput, outputDir: string): Promise<void> {
    const content = `# C4 Architecture Model - ${output.projectName}

> Generated on ${output.timestamp.toLocaleString()}

## Overview

This documentation contains the C4 architecture model for ${output.projectName}, providing multiple views of the system at different levels of abstraction.

## ğŸ“š Documentation Structure

### Architecture Diagrams

- **[Context Diagram](./c4-context.md)** - System context showing actors and external systems
- **[Containers Diagram](./c4-containers.md)** - High-level technology choices and containers
- **[Components Diagram](./c4-components.md)** - Internal components and their relationships

### Additional Resources

- **[Recommendations](./recommendations.md)** - Architecture improvement suggestions
- **[Metadata](./metadata.md)** - Generation details and statistics
- **[Changelog](./changelog.md)** - Documentation update history

## ğŸ¯ Quick Start

1. Start with the [Context Diagram](./c4-context.md) to understand the system boundary
2. Explore the [Containers Diagram](./c4-containers.md) to see high-level architecture
3. Dive into the [Components Diagram](./c4-components.md) for detailed internal structure
4. Review [Recommendations](./recommendations.md) for improvement opportunities

## ğŸ“Š PlantUML Diagrams

The following PlantUML files can be rendered visually:

- \`context.puml\` - Context diagram source
- \`containers.puml\` - Containers diagram source
- \`components.puml\` - Components diagram source

Use PlantUML to generate SVG/PNG diagrams from these files.

---

*Generated by ArchDoc C4 Model Generator*
`;

    await fs.writeFile(path.join(outputDir, 'index.md'), content, 'utf-8');
  }

  private async writeMetadataFile(output: C4ModelOutput, outputDir: string): Promise<void> {
    const content = `# Generation Metadata

## Project Information

- **Project Name**: ${output.projectName}
- **Generated At**: ${output.timestamp.toISOString()}
- **Generation Time**: ${(output.metadata.generationDuration / 1000).toFixed(1)}s

## Scan Results

- **Total Files**: ${output.metadata.totalFiles}
- **Total Directories**: ${output.metadata.totalDirectories}
- **Total Size**: ${((output.scanResult?.totalSize || 0) / 1024 / 1024).toFixed(2)} MB

## Language Distribution

${
  output.scanResult?.languages
    ?.map(
      (lang) => `- **${lang.language}**: ${lang.fileCount} files (${lang.percentage.toFixed(1)}%)`,
    )
    .join('\n') || 'No languages detected'
}

## Agents Executed

${output.metadata.agentsExecuted.map((name, idx) => `${idx + 1}. ${name}`).join('\n') || 'No agents executed'}

## Configuration

- **Max Tokens**: 100,000
- **Token Budget**: Unlimited
- **Parallel Execution**: Disabled (sequential for C4 model)

---

*Last updated: ${output.timestamp.toLocaleString()}*
`;

    await fs.writeFile(path.join(outputDir, 'metadata.md'), content, 'utf-8');
  }

  private async writeContextFile(output: C4ModelOutput, outputDir: string): Promise<void> {
    if (!output.c4Model?.context || !output.c4Model.context.system) {
      return; // Skip if no context data
    }

    const { context } = output.c4Model;
    const plantUML = output.plantUMLModel?.context || '';

    const content = `# C4 Context Diagram

## System Overview

### Main System

**${context.system?.name || 'Unknown System'}**

${context.system?.description || 'No description available'}

## Actors

${
  context.actors
    ?.map(
      (actor: any) => `### ${actor.name}

${actor.description}
`,
    )
    .join('\n') || '*No actors identified*'
}

## External Systems

${
  context.externalSystems
    ?.map(
      (system: any) => `### ${system.name}

${system.description}
`,
    )
    .join('\n') || '*No external systems identified*'
}

## Relationships

${
  context.relationships
    ?.map((rel: any) => `- **${rel.source}** â†’ **${rel.destination}**: ${rel.description}`)
    .join('\n') || '*No relationships defined*'
}

${
  plantUML
    ? `
## PlantUML Diagram

\`\`\`plantuml
${plantUML}
\`\`\`

*Tip: Render this diagram using PlantUML for visualization*
`
    : ''
}

---

[â† Back to Index](./index.md) | [Next: Containers â†’](./c4-containers.md)
`;

    await fs.writeFile(path.join(outputDir, 'c4-context.md'), content, 'utf-8');
  }

  private async writeContainersFile(output: C4ModelOutput, outputDir: string): Promise<void> {
    if (!output.c4Model?.containers || !output.c4Model.containers.containers?.length) {
      return; // Skip if no containers data
    }

    const { containers } = output.c4Model;
    const plantUML = output.plantUMLModel?.containers || '';

    const content = `# C4 Containers Diagram

## Containers

${
  containers.containers
    ?.map(
      (container: any) => `### ${container.name}

- **Technology**: ${container.technology}
- **Description**: ${container.description}
`,
    )
    .join('\n') || '*No containers identified*'
}

## Container Relationships

${
  containers.relationships
    ?.map(
      (rel: any) =>
        `- **${rel.source}** â†’ **${rel.destination}**
  - Protocol: ${rel.technology || 'N/A'}
  - Description: ${rel.description}`,
    )
    .join('\n\n') || '*No relationships defined*'
}

${
  plantUML
    ? `
## PlantUML Diagram

\`\`\`plantuml
${plantUML}
\`\`\`

*Tip: Render this diagram using PlantUML for visualization*
`
    : ''
}

---

[â† Previous: Context](./c4-context.md) | [Back to Index](./index.md) | [Next: Components â†’](./c4-components.md)
`;

    await fs.writeFile(path.join(outputDir, 'c4-containers.md'), content, 'utf-8');
  }

  private async writeComponentsFile(output: C4ModelOutput, outputDir: string): Promise<void> {
    if (!output.c4Model?.components || !output.c4Model.components.components?.length) {
      return; // Skip if no components data
    }

    const { components } = output.c4Model;
    const plantUML = output.plantUMLModel?.components || '';

    const content = `# C4 Components Diagram

## Container: ${components.containerName || 'Unknown Container'}

### Components

${
  components.components
    ?.map(
      (component: any) => `#### ${component.name}

${component.description}
`,
    )
    .join('\n') || '*No components identified*'
}

## Component Relationships

${
  components.relationships
    ?.map((rel: any) => `- **${rel.source}** â†’ **${rel.destination}**: ${rel.description}`)
    .join('\n') || '*No relationships defined*'
}

${
  plantUML
    ? `
## PlantUML Diagram

\`\`\`plantuml
${plantUML}
\`\`\`

*Tip: Render this diagram using PlantUML for visualization*
`
    : ''
}

---

[â† Previous: Containers](./c4-containers.md) | [Back to Index](./index.md)
`;

    await fs.writeFile(path.join(outputDir, 'c4-components.md'), content, 'utf-8');
  }

  private async writeRecommendationsFile(output: C4ModelOutput, outputDir: string): Promise<void> {
    const recommendations: string[] = [];

    // Analyze Context level
    if (output.c4Model?.context) {
      const actors = output.c4Model.context.actors || [];
      const externalSystems = output.c4Model.context.externalSystems || [];

      if (actors.length === 0) {
        recommendations.push(
          'âš ï¸ **No User Actors Identified**: Consider defining specific user personas/roles who interact with the system for better requirements tracking.',
        );
      }

      if (externalSystems.length > 5) {
        recommendations.push(
          `âš ï¸ **High External Dependencies** (${externalSystems.length} systems): Review if all external integrations are necessary. Consider API gateways or adapter patterns to reduce coupling.`,
        );
      }

      if (externalSystems.length === 0) {
        recommendations.push(
          'âš ï¸ **No External Systems**: Most production systems depend on databases, caches, or third-party APIs. Verify if all dependencies are captured.',
        );
      }
    }

    // Analyze Containers level
    if (output.c4Model?.containers) {
      const containersData = output.c4Model.containers;
      // Handle both array and object with containers property
      let containers: any[] = [];
      if (Array.isArray(containersData)) {
        containers = containersData;
      } else if (
        containersData &&
        typeof containersData === 'object' &&
        'containers' in containersData
      ) {
        containers = containersData.containers || [];
      }

      if (containers.length === 0) {
        recommendations.push(
          'âš ï¸ **No Containers Defined**: Unable to identify deployable units. Add Dockerfile/docker-compose or document deployment architecture.',
        );
      } else if (containers.length === 1) {
        recommendations.push(
          `â„¹ï¸ **Monolithic Architecture**: Single container deployment detected. Consider microservices if: 1) Team size > 10, 2) Different scaling needs per module, 3) Independent deployment required.`,
        );
      } else if (containers.length > 10) {
        recommendations.push(
          `âš ï¸ **High Container Count** (${containers.length} containers): May indicate over-fragmentation. Consider consolidating related services or using modular monolith pattern.`,
        );
      }

      // Check for missing database containers
      const hasDatabase = containers.some(
        (c: any) =>
          c.name.toLowerCase().includes('database') ||
          c.name.toLowerCase().includes('db') ||
          c.technology?.toLowerCase().includes('postgres') ||
          c.technology?.toLowerCase().includes('mysql') ||
          c.technology?.toLowerCase().includes('mongo'),
      );

      if (!hasDatabase && output.c4Model.context?.externalSystems?.length > 0) {
        recommendations.push(
          'â„¹ï¸ **Database Container Missing**: If using a database, consider documenting it as a container with specific technology (PostgreSQL, MongoDB, etc.).',
        );
      }
    }

    // Analyze Components level
    if (output.c4Model?.components) {
      const componentsData = output.c4Model.components;
      // Handle both array and object with components property
      let components: any[] = [];
      if (Array.isArray(componentsData)) {
        components = componentsData;
      } else if (
        componentsData &&
        typeof componentsData === 'object' &&
        'components' in componentsData
      ) {
        components = componentsData.components || [];
      }

      if (components.length === 0) {
        recommendations.push(
          'âš ï¸ **No Internal Components**: Unable to identify internal architecture. Ensure key modules/services are documented.',
        );
      } else if (components.length < 3) {
        recommendations.push(
          `â„¹ï¸ **Limited Component Detail** (${components.length} components): Consider breaking down into more granular components (Controllers, Services, Repositories) for better understanding.`,
        );
      } else if (components.length > 20) {
        recommendations.push(
          `âš ï¸ **High Component Complexity** (${components.length} components): Large number of components may indicate lack of module boundaries. Consider grouping related components into bounded contexts.`,
        );
      }

      // Check for layering patterns
      const hasController = components.some((c: any) =>
        c.name.toLowerCase().includes('controller'),
      );
      const hasService = components.some((c: any) => c.name.toLowerCase().includes('service'));
      const hasRepository = components.some((c: any) =>
        c.name.toLowerCase().includes('repository'),
      );

      if (hasController && hasService && hasRepository) {
        recommendations.push(
          'âœ… **Layered Architecture Detected**: Controller â†’ Service â†’ Repository pattern provides good separation of concerns.',
        );
      } else if (components.length > 5) {
        recommendations.push(
          'â„¹ï¸ **Consider Layered Architecture**: Adopt Controller/Service/Repository pattern for clear separation between presentation, business logic, and data access.',
        );
      }
    }

    // Agent-specific recommendations
    const patternAgent = output.agentResults?.get('pattern-detector');
    if (patternAgent?.markdown) {
      const markdown = patternAgent.markdown.toLowerCase();
      if (markdown.includes('singleton') && markdown.includes('not recommended')) {
        recommendations.push(
          'âš ï¸ **Singleton Pattern Concerns**: Excessive singleton usage detected. Consider dependency injection for better testability.',
        );
      }
      if (!markdown.includes('factory') && !markdown.includes('strategy')) {
        recommendations.push(
          'â„¹ï¸ **Design Pattern Opportunities**: Consider Factory or Strategy patterns to improve code flexibility and extensibility.',
        );
      }
    }

    const securityAgent = output.agentResults?.get('security-analyzer');
    if (securityAgent?.markdown) {
      const securityIssues = (securityAgent.markdown.match(/vulnerability|security|risk/gi) || [])
        .length;
      if (securityIssues > 5) {
        recommendations.push(
          `âš ï¸ **Security Review Needed**: ${securityIssues} security-related items identified. Prioritize addressing authentication, authorization, and data protection.`,
        );
      }
    }

    // Build final content
    const content = `# Architecture Recommendations

## Overview

Based on the C4 model analysis of **${output.c4Model?.context?.system?.name || 'this system'}**, here are specific recommendations for improving the architecture.

## Analysis Summary

- **Context Level**: ${output.c4Model?.context?.actors?.length || 0} actors, ${output.c4Model?.context?.externalSystems?.length || 0} external systems
- **Containers Level**: ${output.c4Model?.containers?.length || 0} deployable units
- **Components Level**: ${output.c4Model?.components?.length || 0} internal components

## Recommendations

${recommendations.length > 0 ? recommendations.map((r, i) => `### ${i + 1}. ${r}\n`).join('\n') : 'âœ… **No Critical Issues Detected**: Architecture model looks well-structured. Continue monitoring as system evolves.\n'}

## General Best Practices

### Documentation Maintenance
- ğŸ“ Update C4 diagrams whenever architecture changes significantly
- ğŸ“– Document architectural decisions using ADRs (Architecture Decision Records)
- ğŸ”„ Review diagrams quarterly to ensure accuracy

### Monitoring & Observability
- ğŸ“Š Add observability for all external system integrations
- â±ï¸ Track latency and error rates per container
- ğŸ“ˆ Monitor resource usage (CPU, memory, network) per deployment unit

### Security & Compliance
- ğŸ” Implement authentication/authorization at system boundaries
- ğŸ”’ Encrypt sensitive data in transit and at rest
- ğŸ›¡ï¸ Regular security audits of external dependencies

### Scalability Planning
- ğŸ“ˆ Identify bottlenecks in high-traffic components
- âš–ï¸ Plan horizontal scaling strategies for stateless services
- ğŸ’¾ Consider caching for frequently accessed data

## Next Steps

1. âœ… Review each recommendation above and assess applicability
2. ğŸ¯ Prioritize recommendations based on business impact
3. ğŸ“‹ Create action items for high-priority improvements
4. ğŸ”„ Revisit architecture quarterly as system evolves

---

*Generated: ${new Date().toLocaleString()}* | *Based on C4 Model Analysis*

[â† Back to Index](./index.md)
`;

    await fs.writeFile(path.join(outputDir, 'recommendations.md'), content, 'utf-8');
  }

  private async writeChangelogFile(output: C4ModelOutput, outputDir: string): Promise<void> {
    const content = `# Changelog

## ${output.timestamp.toISOString().split('T')[0]}

### Initial Generation

- âœ¨ Generated C4 architecture model
- ğŸ“Š Created Context, Containers, and Components diagrams
- ğŸ“ Generated PlantUML sources
- ğŸ’¡ Added architecture recommendations

---

*Generated at: ${output.timestamp.toISOString()}*

[â† Back to Index](./index.md)
`;

    await fs.writeFile(path.join(outputDir, 'changelog.md'), content, 'utf-8');
  }

  private async writePlantUMLFiles(output: C4ModelOutput, outputDir: string): Promise<void> {
    await Promise.all([
      fs.writeFile(path.join(outputDir, 'context.puml'), output.plantUMLModel.context, 'utf-8'),
      fs.writeFile(
        path.join(outputDir, 'containers.puml'),
        output.plantUMLModel.containers,
        'utf-8',
      ),
      fs.writeFile(
        path.join(outputDir, 'components.puml'),
        output.plantUMLModel.components,
        'utf-8',
      ),
    ]);
  }
}
